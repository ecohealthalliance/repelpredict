---
title: "REPEL nowcast"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 10, fig.height = 10)
devtools::load_all()
library(yardstick)
library(ggplot2)
library(kableExtra)
library(cowplot)
library(DALEX)
library(knitr)

conn <- repeldata::repel_local_conn()
grouping_vars <- c("country_iso3c", "report_year", "report_semester", "disease", "disease_population", "taxa")

traindat <- annual_reports_animal_hosts_training(conn) %>%
  select(all_of(grouping_vars)) %>%
  distinct()

oie_high_importance_diseases <- get_oie_high_importance_diseases()

```

```{r load-data}
# augmented_data_baseline <- repel_augment(model_object = nowcast_baseline_model(), conn = conn, newdata = traindat)
# predicted_cases_baseline <- repel_predict(model_object = nowcast_baseline_model(), newdata = augmented_data_baseline)
# scored_data_baseline <- repel_score(model_object = nowcast_baseline_model(), augmented_data = augmented_data_baseline, predicted_cases = predicted_cases_baseline)

forecasted_baseline <- repel_forecast(model_object = nowcast_baseline_model(),
                                  conn = conn,
                                  newdata = traindat)

scored_baseline <- repel_score(model_object = nowcast_baseline_model(),
                               augmented_data = forecasted_baseline$augmented_data,
                               predicted_cases = forecasted_baseline$predicted_cases)


#augmented_data_boost <- repel_augment(model_object = nowcast_boost_model(), conn = conn, newdata = traindat)
# augmented_data_boost <- read_rds(here::here("tmp/augmented_data.rds"))
# predicted_cases_boost <- repel_predict(model_object =  nowcast_boost_model(
#   disease_status_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_disease_status.rds"),
#   cases_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_cases.rds")), newdata = augmented_data_boost)
# scored_data_boost <- repel_score(model_object = model_object =  nowcast_boost_model(
#   disease_status_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_disease_status.rds"),
#   cases_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_cases.rds")), augmented_data = augmented_data_boost, predicted_cases = predicted_cases_boost)
model_object <-  nowcast_boost_model(
  disease_status_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_disease_status.rds"),
  cases_model = aws.s3::s3readRDS(bucket = "repeldb/models", object = "boost_mod_cases.rds"))

forecasted_boost <- repel_forecast(model_object = model_object,
                                  conn = conn,
                                  newdata = traindat, use_cache = TRUE)

scored_boost <- repel_score(model_object = model_object,
                               augmented_data = forecasted_boost$augmented_data,
                               predicted_cases = forecasted_boost$predicted_cases)


```

We are using a two-component hurdle model: first, the model predicts whether a disease will be present (binary), and if present, it predicts the case count (integer). Here we compare the results of a boosted tree model to our baseline model.

### Disease Status
```{r ds-cm}
scored_data_ds_baseline <- scored_baseline$scored_tibble %>% 
  select(taxa, country_iso3c, disease_status_actual, disease_status_predicted, disease_status_dirchange_actual, disease_status_dirchange_predicted) %>% 
  mutate(model = "baseline")
scored_data_ds_boost <- scored_boost$scored_tibble %>% 
  select(taxa, country_iso3c, disease_status_actual, disease_status_predicted, disease_status_dirchange_actual, disease_status_dirchange_predicted) %>% 
  mutate(model = "xgboost")

scored_data_ds <- bind_rows(scored_data_ds_baseline, scored_data_ds_boost) %>% 
  mutate_at(.vars = c("disease_status_actual", "disease_status_predicted", "disease_status_dirchange_actual", "disease_status_dirchange_predicted"), as.factor) %>% 
  mutate(continent = countrycode::countrycode(country_iso3c, origin = "iso3c", destination = "continent")) %>% 
  mutate(full_model = "full_model") # dummy var

metrics <- tribble(~".metric", ~"desc",
                   "accuracy", "proportion of the data that are predicted correctly",
                   "kap", "similar measure to accuracy(), but is normalized by the accuracy that would be expected by chance alone and is very useful when one or more classes have large frequency distributions.",
                   "sens", "the proportion of disease absent predictions out of the number of events which were actually absent",
                   "spec", "the proportion of disease present predictions out of the number of events which were actually present")

ds_summary <- function(grp_var, truth, estimate){
  
  cm_scored_mat <- scored_data_ds %>% 
    mutate(lab = paste(model, get(grp_var), sep = " - ")) %>% 
    group_by_at(c("model", "lab", grp_var)) %>% 
    conf_mat(truth = truth, estimate = estimate) %>% 
    ungroup()
  
  cm_scored_summ <- cm_scored_mat %>% 
    mutate(summary = map(conf_mat, summary)) %>% 
    unnest(summary) %>% 
    right_join(metrics)
  
  out_table <- cm_scored_summ %>% 
    select(one_of(grp_var), .metric, desc, model, .estimate) %>% 
    mutate(.estimate = signif(.estimate, 2)) %>% 
    pivot_wider(names_from = all_of(grp_var), values_from = .estimate) %>% 
    arrange(.metric)
  
  out_plots <- map(cm_scored_mat$conf_mat, autoplot, type = "heatmap")
  out_plots <- plot_grid(plotlist = out_plots, labels = cm_scored_mat$lab, label_size = 8)
  
  return(list(out_table, out_plots))
}

```

<details>
<summary>disease status confusion matrix</summary>
```{r ds-cm-full-model, fig.width = 10, fig.height = 5}
out_full_model <- ds_summary("full_model", truth = "disease_status_actual", estimate = "disease_status_predicted")
out_full_model[[1]]  %>% 
  kbl() %>% 
  collapse_rows(columns = 1:2, valign = "middle") %>% 
  kable_styling() 
out_full_model[[2]]
```
</details>

<details>
<summary>disease status confusion matrix by taxa</summary>
```{r ds-cm-status-taxa, fig.width = 10, fig.height = 10}
out_full_model_taxa <- ds_summary("taxa",  truth = "disease_status_actual", estimate = "disease_status_predicted")
out_full_model_taxa[[1]] %>% 
  select(-desc) %>% 
  kbl() %>% 
  collapse_rows(columns = 1, valign = "middle") %>% 
  kable_styling() 
out_full_model_taxa[[2]]
```
</details>

<details>
<summary>disease status confusion matrix by continent</summary>
```{r ds-cm-status-continent, fig.width = 10, fig.height = 8}
out_full_model_continent <- ds_summary("continent",  truth = "disease_status_actual", estimate = "disease_status_predicted")
out_full_model_continent[[1]]  %>% 
  select(-desc) %>% 
  kbl() %>% 
  collapse_rows(columns = 1, valign = "middle") %>% 
  kable_styling() 
out_full_model_continent[[2]]
```
</details>

<details>
<summary>disease status direction change confusion matrix</summary>
```{r ds-cm-full-model-dc, fig.width = 10, fig.height = 5}
out_full_model_dc <- ds_summary("full_model", truth = "disease_status_dirchange_actual", estimate = "disease_status_dirchange_predicted")
out_full_model_dc[[1]]  %>% 
  filter(! .metric %in% c("sens", "spec")) %>% 
  kbl() %>% 
  collapse_rows(columns = 1:2, valign = "middle") %>% 
  kable_styling() 
out_full_model_dc[[2]]
```
Note there are some baseline "outbreak ends" predictions. This occurs in cases where the lag1 disease status is 1, but the lag1 cases are 0 or NA. The predict() function predicts lag1 cases only when the lag1 disease status is 1. 

</details>

<details>
<summary>disease status direction change confusion matrix by taxa</summary>
```{r ds-cm-taxa-dc, fig.width = 15, fig.height = 10}
out_taxa_dc <- ds_summary("taxa", truth = "disease_status_dirchange_actual", estimate = "disease_status_dirchange_predicted")
out_taxa_dc[[1]]  %>% 
  select(-desc) %>% 
  filter(! .metric %in% c("sens", "spec")) %>% 
  kbl() %>% 
  collapse_rows(columns = 1, valign = "middle") %>% 
  kable_styling() 
out_taxa_dc[[2]]
```
</details>

<details>
<summary>disease status direction change confusion matrix by continent</summary>
```{r ds-cm-continent-dc, fig.width = 15, fig.height = 8}
out_continent_dc <- ds_summary("continent", truth = "disease_status_dirchange_actual", estimate = "disease_status_dirchange_predicted")
out_continent_dc[[1]]  %>% 
  select(-desc) %>% 
  filter(! .metric %in% c("sens", "spec")) %>% 
  kbl() %>% 
  collapse_rows(columns = 1, valign = "middle") %>% 
  kable_styling() 
out_continent_dc[[2]]
```
</details>

<details>
<summary>disease status variable importance and partial dependency (xgboost only) </summary>
```{r ds-var_import, fig.width = 15, fig.height = 10}
# Load model
boost_mod_disease_status <- read_rds(here::here("models/boost_mod_disease_status.rds"))
boost_mod_disease_status_xg <- pull_workflow_fit(boost_mod_disease_status)

# Variable importance
importance_disease_status <- vip::vip(boost_mod_disease_status_xg, num_features = 12)
importance_disease_status + 
  theme(axis.text = element_text(size = 14))

top_vars <- importance_disease_status$data$Variable

# Get training data
boost_dat_disease_status <- pull_workflow_mold(boost_mod_disease_status)$predictors %>% 
  as.matrix()
boost_dat_out_disease_status <- pull_workflow_mold(boost_mod_disease_status)$outcomes %>% 
  mutate(disease_status = as.integer(disease_status == 1)) %>% 
  pull(disease_status)

explainer_disease_status <- DALEX::explain(
  model = boost_mod_disease_status_xg,
  data = boost_dat_disease_status,
  y = boost_dat_out_disease_status,
  predict_function = predict_raw,
  label = "disease status",
  verbose = FALSE
)

#importance_disease_status <- variable_importance(explainer = explainer_disease_status)

pd_disease_status <- map(top_vars, function(var){
  if(n_distinct(boost_dat_disease_status[,var]) == 2){
    variable_type <- "categorical"
    geom <- "aggregates" # bar plots
  } else {
    variable_type <- "numerical"
    geom <- "profiles"  # ceteris-paribus (CP) profiles
  }
  
  var_resp <- model_profile(explainer_disease_status, variable =  var , type = "partial", variable_type = variable_type)
  plot(var_resp, geom = geom) +
    labs(title = "", subtitle = "")
})
plot_grid(plotlist = pd_disease_status)

```
</details>

```{r ds-var-pd-by-disease, fig.height=10, fig.width=15}
ds_lag_pd_by_disease <-  map(oie_high_importance_diseases, function(disease){
  
  col <- paste("disease", disease, sep = "_")
  if(col %in% colnames(boost_dat_disease_status)){
    which_disease <- which(boost_dat_disease_status[,col] == 1)
    
    if(length(which_disease)){
      explainer_disease_status_sub <- DALEX::explain(
        model = boost_mod_disease_status_xg,
        data = boost_dat_disease_status[which_disease,],
        y = boost_dat_out_disease_status[which_disease],
        predict_function = predict_raw,
        label = "disease status",
        verbose = FALSE
      )
      
      map(top_vars, function(var){
        
        if(n_distinct(boost_dat_disease_status[,var]) == 2){
          variable_type <- "categorical"
          geom <- "aggregates" # bar plots
        } else {
          variable_type <- "numerical"
          geom <- "profiles"  # ceteris-paribus (CP) profiles
        }
        
        var_resp <- model_profile(explainer_disease_status_sub, variable =  var , type = "partial", variable_type = variable_type)
        plot(var_resp, geom = geom) +
          labs(title = disease, subtitle = "")
      })
    }
  }
})
write_rds(ds_lag_pd_by_disease, here::here("tmp/ds_lag_pd_by_disease.rds"))
ds_lag_pd_by_disease <- read_rds(here::here("tmp/ds_lag_pd_by_disease.rds"))
ds_lag_pd_by_disease <- purrr::transpose(ds_lag_pd_by_disease)
names(ds_lag_pd_by_disease) <- top_vars
```

```{r, include = FALSE}
src <- purrr::map_chr(seq_along(ds_lag_pd_by_disease), ~ {
  tab_name <- top_vars[.x]
  knit_expand(text = c("<details>",
                       "<summary>disease status partial dependency of {{tab_name}} by select disease (xgboost only)</summary>",
                       "```{r ds-var-pd-by-disease-{{.x}}, echo = FALSE, align = 'left'}", 
                       "plot_grid(plotlist = ds_lag_pd_by_disease[[{{.x}}]])",
                       "```",
                       "</details>"))
})
```
`r knit_child(text = src)`

```{r ds-var-pd-by-dirchage, fig.height=10, fig.width=15}

boost_dat_disease_status_dirchange <- pull_workflow_mold(boost_mod_disease_status)$predictors  %>%
  select(disease_status_lag1) %>%
  mutate(disease_status_actual = boost_dat_out_disease_status) %>%
  mutate(disease_status_dirchange_actual = disease_status_actual - disease_status_lag1) %>%
  mutate(disease_status_dirchange_actual = case_when(disease_status_dirchange_actual == 0 ~ "no change",
                                                     disease_status_dirchange_actual > 0 ~ "outbreak starts",
                                                     disease_status_dirchange_actual < 0 ~ "outbreak ends")) %>%
  pull(disease_status_dirchange_actual)

ds_lag_pd_by_dirchange <-  map(unique(boost_dat_disease_status_dirchange), function(chng){
  
  which_chng <-  which(boost_dat_disease_status_dirchange == chng)
  explainer_disease_status_sub2 <- DALEX::explain(
    model = boost_mod_disease_status_xg,
    data = boost_dat_disease_status[which_chng,],
    y = boost_dat_out_disease_status[which_chng],
    predict_function = predict_raw,
    label = "disease status",
    verbose = FALSE
  )
  
  map(top_vars, function(var){
    
    if(n_distinct(boost_dat_disease_status[,var]) == 2){
      variable_type <- "categorical"
      geom <- "aggregates" # bar plots
    } else {
      variable_type <- "numerical"
      geom <- "profiles"  # ceteris-paribus (CP) profiles
    }
    
    var_resp <- model_profile(explainer_disease_status_sub2, variable =  var , type = "partial", variable_type = variable_type)
    plot(var_resp, geom = geom) +
      labs(title = chng, subtitle = "")
  })
})
write_rds(ds_lag_pd_by_dirchange, here::here("tmp/ds_lag_pd_by_dirchange.rds"))
ds_lag_pd_by_dirchange <- read_rds(here::here("tmp/ds_lag_pd_by_dirchange.rds"))
ds_lag_pd_by_dirchange <- purrr::transpose(ds_lag_pd_by_dirchange)
names(ds_lag_pd_by_dirchange) <- top_vars

```

```{r, include = FALSE}
src <- purrr::map_chr(seq_along(top_vars), ~ {
  tab_name <- top_vars[.x]
  knit_expand(text = c("<details>",
                       "<summary>disease status partial dependency of {{tab_name}} by select direction change (xgboost only)</summary>",
                       "```{r ds-var-pd-by-dirchange-{{.x}}, echo = FALSE, align = 'left'}", 
                       "plot_grid(plotlist = ds_lag_pd_by_dirchange[[{{.x}}]])",
                       "```",
                       "</details>"))
})
```
`r knit_child(text = src)`

### Cases
Here we evaluate the subset of the training data with positive case counts

<details>
<summary>cases model stats</summary>
```{r cs-stats}
scored_data_cs_baseline <- scored_data_baseline$scored_tibble %>%
  select(disease, taxa, country_iso3c, cases_actual, cases_predicted, cases_dirchange_actual, cases_dirchange_predicted, cases_error) %>%
  mutate(model = "baseline") %>%
  drop_na(cases_actual)
scored_data_cs_boost <- scored_data_boost$scored_tibble%>%
  select(disease, taxa, country_iso3c, cases_actual, cases_predicted, cases_dirchange_actual, cases_dirchange_predicted, cases_error) %>%
  mutate(model = "xgboost") %>%
  drop_na(cases_actual)

scored_data_cs <- bind_rows(scored_data_cs_baseline, scored_data_cs_boost) %>%
  mutate(continent = countrycode::countrycode(country_iso3c, origin = "iso3c", destination = "continent")) %>%
  mutate(full_model = "full_model") # dummy var

scored_data_cs %>%
  group_by(model) %>%
  yardstick::metrics(truth = cases_actual, estimate = cases_predicted)
```
</details>

<details>
<summary>cases residuals</summary>
```{r cd-resid, fig.height=5}
scored_data_cs %>%
  ggplot(., aes(x = cases_actual, y = cases_predicted, color = log10(cases_error))) +
  geom_point(alpha = 0.5) +
  facet_wrap(model ~ .) +
  scale_y_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_x_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_color_viridis_c() +
  theme_bw()
```
</details>

<details>
<summary>cases residuals by taxa</summary>
```{r cd-resid-taxa, fig.height=10, fig.width=15}
scored_data_cs %>%
  ggplot(., aes(x = cases_actual, y = cases_predicted, color = log10(cases_error))) +
  geom_point(alpha = 0.5) +
  facet_grid(model ~ taxa) +
  scale_y_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_x_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_color_viridis_c() +
  theme_bw()
```
</details>

<details>
<summary>cases residuals by continent</summary>
```{r cd-resid-continent, fig.height=10, fig.width=15}
scored_data_cs %>%
  ggplot(., aes(x = cases_actual, y = cases_predicted, color = log10(cases_error))) +
  geom_point(alpha = 0.5) +
  facet_grid(model ~ continent) +
  scale_y_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_x_log10(limits = c(1, max(c(scored_data_cs$cases_actual, scored_data_cs$cases_predicted)))) +
  scale_color_viridis_c() +
  theme_bw()
```
</details>


<details>
<summary>cases variable importance and partial dependency (xgboost only) </summary>
```{r cs-var-import, fig.width = 15, fig.height = 10}
# Load model
boost_mod_cases <- read_rds(here::here("models/boost_mod_cases.rds"))
boost_mod_cases_xg <- pull_workflow_fit(boost_mod_cases)

# Variable importance
importance_cases <- vip::vip(boost_mod_cases_xg, num_features = 12)
importance_cases +
  theme(axis.text = element_text(size = 14))

top_vars <- importance_cases$data$Variable

# Get training data
boost_dat_cases <- pull_workflow_mold(boost_mod_cases)$predictors %>%
  as.matrix()
boost_dat_out_cases <- pull_workflow_mold(boost_mod_cases)$outcomes %>%
  pull(cases)

explainer_cases <- DALEX::explain(
  model = boost_mod_cases_xg,
  data = boost_dat_cases,
  y = boost_dat_out_cases,
  predict_function = predict_raw,
  label = "cases",
  verbose = FALSE
)

# how does the expected value of model prediction behave as a function of a selected explanatory variable?
# a CP profile shows the dependence of an instance-level prediction on an explanatory variable. A PD profile is estimated by the mean of the CP profiles for all instances (observations) from a dataset.
# these are aggregated profiles. By default 100.
pd_cases <- map(top_vars, function(var){
  if(n_distinct(boost_dat_cases[,var]) == 2){
    variable_type <- "categorical"
    geom <- "aggregates" # bar plots
  } else {
    variable_type <- "numerical"
    geom <- "profiles"  # ceteris-paribus (CP) profiles
  }
  
  var_resp <- model_profile(explainer_cases, variable =  var , type = "partial", variable_type = variable_type)
  plot(var_resp, geom = geom) +
    labs(title = "", subtitle = "")
})
plot_grid(plotlist = pd_cases)
```
</details>


```{r cs-var-pd-by-disease, fig.height=10, fig.width=15}
cs_lag_pd_by_disease <-  map(oie_high_importance_diseases, function(disease){
  
  col <- paste("disease", disease, sep = "_")
  if(col %in% colnames(boost_dat_cases)){
    which_disease <- which(boost_dat_cases[,col] == 1)
    
    if(length(which_disease)){
      explainer_cases_sub <- DALEX::explain(
        model = boost_mod_cases_xg,
        data = boost_dat_cases[which_disease,],
        y = boost_dat_out_cases[which_disease],
        predict_function = predict_raw,
        label = "cases",
        verbose = FALSE
      )
      
      map(top_vars, function(var){
        
        if(n_distinct(boost_dat_cases[,var]) == 2){
          variable_type <- "categorical"
          geom <- "aggregates" # bar plots
        } else {
          variable_type <- "numerical"
          geom <- "profiles"  # ceteris-paribus (CP) profiles
        }
        
        var_resp <- model_profile(explainer_cases_sub, variable =  var , type = "partial", variable_type = variable_type)
        plot(var_resp, geom = geom) +
          labs(title = disease, subtitle = "")
      })
    }
  }
})
write_rds(cs_lag_pd_by_disease, here::here("tmp/cs_lag_pd_by_disease.rds"))
cs_lag_pd_by_disease <- read_rds(here::here("tmp/cs_lag_pd_by_disease.rds"))
cs_lag_pd_by_disease <- purrr::compact(cs_lag_pd_by_disease)
cs_lag_pd_by_disease <- purrr::transpose(cs_lag_pd_by_disease)
names(cs_lag_pd_by_disease) <- top_vars
```

```{r, include = FALSE}
src <- purrr::map_chr(seq_along(cs_lag_pd_by_disease), ~ {
  tab_name <- top_vars[.x]
  knit_expand(text = c("<details>",
                       "<summary>cases partial dependency of {{tab_name}} by select disease (xgboost only)</summary>",
                       "```{r cs-var-pd-by-disease-{{.x}}, echo = FALSE, align = 'left'}", 
                       "plot_grid(plotlist = cs_lag_pd_by_disease[[{{.x}}]])",
                       "```",
                       "</details>"))
})
```
`r knit_child(text = src)`


```{r disconnect}
repel_local_disconnect()
```

